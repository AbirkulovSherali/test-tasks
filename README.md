## Тестовое задание
#### Описание
1. Необходимо выполнить поиск по дереву объекта: найти все значения равные единице и вывести их пути нахождения (в консоль браузера). 
Типами свойств могут быть строки, массивы, числа, а так же вложенные объекты.
2. Выполнить рендеринг первого задания с помощью блочных элементов так, чтобы была видна четкая структура дерева,
закрасить цветом блоки, в которых отрисовываются найденные значения.
3. Выполнить выше перечисленные задания с использованием сборщика модулей Webpack.

#### 1. Поиск указанных значений
```javascript
/* Задание 1: вывод путей свойств дерева со значением '1' */
function getValue1(tree, curPath = ''){
    let prop;
    for(prop in tree){
        if(tree[prop] === 1){
            console.log(tree[prop], curPath + prop);
        }

        if(Array.isArray(tree[prop])){
            for(let i = 0; i < tree[prop].length; i++){
                if(tree[prop][i] === 1) {
                    console.log(tree[prop][i], curPath + i);
                }
            }

            continue;
        }

        if(typeof(tree[prop]) === 'object'){
            prevPath = curPath;
            curPath += prop + ' > ';
            getValue1(tree[prop], curPath);
            curPath = prevPath;
        }
    }
}
```
Функция принимает 2 аргумента, последний используется для замыкания и его не нужно передавать при вывозове функции: объекто-дерево, текущий путь
```javascript
getValue1(tree) 
```
В цикле проходимся по свойствам объекта, и если значение свойства равно единице, то выводим значение свойства и его путь в консоль
```javascript
for(prop in tree){
if(tree[prop] === 1){
    console.log(tree[prop], curPath + prop);
}
/*...................*/
```
Если значение свойства является массивом, то перебираем его с помощью цикла for, так как если этого не сделать,
то массив будет перебераться в цикле for...in, которые желательно не использовать при трассировке массива с индексами из-за того, что он так же может перебрать не только элементы, но и свойства массива, которые нам не нужны. После трассирвоки массива пропускаем текущую итерацию внешнего массива, чтобы он не попал под перебор внешнего цикла for...in
```javascript
/*...................*/
if(tree[prop] === 1){
    if(Array.isArray(tree[prop])){
        for(let i = 0; i < tree[prop].length; i++){
            if(tree[prop][i] === 1) {
                console.log(tree[prop][i], curPath + i);
            }
        }

        continue;
    }
}
/*...................*/
```
